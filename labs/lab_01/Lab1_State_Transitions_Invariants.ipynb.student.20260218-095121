{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "0",
   "metadata": {},
   "source": [
    "# Lab 1 ‚Äî Computational Thinking with Python  \n",
    "## State ‚Ä¢ Transitions ‚Ä¢ Invariants \n",
    "\n",
    "**Instructions**\n",
    "- Complete each part below.\n",
    "- Do not jump straight to code: read the *State / Transitions / Invariants* scaffolding first.\n",
    "- Write brief answers to the ‚ÄúInvariant Check‚Äù prompts (Markdown cells).\n",
    "- Save your work and commit + sync.\n",
    "\n",
    "---\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "1",
   "metadata": {},
   "source": [
    "## üß© Part 1A ‚Äî Hollow Diamond (Two-Loops Approach)\n",
    "\n",
    "### Problem\n",
    "Ask the user for an **odd integer height** and print a **hollow (outline) diamond** using `*`.  \n",
    "Only the outline should be stars; the inside should be spaces.\n",
    "\n",
    "### Example output (height = 9)\n",
    "```\n",
    "    *\n",
    "   * *\n",
    "  *   *\n",
    " *     *\n",
    "*       *\n",
    " *     *\n",
    "  *   *\n",
    "   * *\n",
    "    *\n",
    "```\n",
    "\n",
    "### State \n",
    "- `height`: odd integer ‚â• 1 (user input)\n",
    "- `mid`: midpoint row index, `height // 2`\n",
    "- `row`: current row index within a half (top or bottom)\n",
    "- `leading_spaces`: spaces before the first `*`\n",
    "- `inner_spaces`: spaces between the two `*` characters (only for rows with two stars)\n",
    "- `line`: the final string printed for the row\n",
    "\n",
    "### Transitions \n",
    "**Top half (including the middle row):**\n",
    "- `row` increases from `0` to `mid`\n",
    "- `leading_spaces` decreases by 1 each step\n",
    "- `inner_spaces` increases by 2 each step\n",
    "- Special case: when `row == 0`, there is only **one** `*`\n",
    "\n",
    "**Bottom half:**\n",
    "- `row` decreases from `mid-1` down to `0`\n",
    "- `leading_spaces` increases by 1 each step\n",
    "- `inner_spaces` decreases by 2 each step\n",
    "- Special case: when `row == 0`, there is only **one** `*`\n",
    "\n",
    "### Invariants \n",
    "For every printed row:\n",
    "1. **Left padding invariant:** the first `*` appears after exactly `leading_spaces` spaces.\n",
    "2. **Outline invariant:**  \n",
    "   - If it‚Äôs the very top or very bottom row ‚Üí exactly **one** `*` is printed.  \n",
    "   - Otherwise ‚Üí exactly **two** `*` are printed, separated by `inner_spaces` spaces.\n",
    "3. **Symmetry invariant:** the pattern is symmetric about the vertical centerline.\n",
    "4. **Bounds invariant:** `0 <= leading_spaces <= mid` and `inner_spaces` is never negative on rows that print two stars.\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "3",
   "metadata": {},
   "source": [
    "### ‚úçÔ∏è Invariant Check (write your answer here)\n",
    "- Pick one non-tip row (a row with **two** `*`). Explain why the **width invariant** holds for that row:\n",
    "  - Why is the first `*` placed correctly? \n",
    "\n",
    "Because we print exactly leading_spaces = mid - row spaces before printing \"*\". That guarantees the first star moves left as row increases and stays centered.\n",
    "\n",
    "  - Why does the second `*` land symmetrically? \n",
    "\n",
    "Because inner_spaces = 2*row - 1, which grows by 2 each row. That makes the gap expand evenly on both sides of the center.\n",
    "\n",
    "- Explain why the ‚Äútip row‚Äù (one `*`) is a necessary special case.\n",
    "\n",
    "When row == 0, inner_spaces = -1.\n",
    "You cannot print negative spaces.\n",
    "Also the top and bottom of a diamond must only have one star, otherwise it would be a square.\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "4",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "  *\n",
      " * *\n",
      "*   *\n",
      " * *\n",
      "  *\n"
     ]
    }
   ],
   "source": [
    "# Part 1A ‚Äî Hollow Diamond (Two Loops)\n",
    "\n",
    "# TODO: Prompt for an odd integer height\n",
    "height = int(input(\"Enter an odd number for the diamond height: \"))\n",
    "\n",
    "# TODO: Compute midpoint\n",
    "mid = height // 2\n",
    "\n",
    "# TODO: Top half (row: 0..mid)\n",
    "# For each row:\n",
    "#   compute leading_spaces and inner_spaces\n",
    "#   build line using the outline rules (1 star on first row, 2 stars otherwise)\n",
    "#   print line\n",
    "\n",
    "for row in range(0, mid + 1):\n",
    "    leading_spaces = mid - row\n",
    "    inner_spaces = 2 * row - 1\n",
    "\n",
    "    if row == 0:\n",
    "        line = \" \" * leading_spaces + \"*\"\n",
    "    else:\n",
    "        line = \" \" * leading_spaces + \"*\" + \" \" * inner_spaces + \"*\"\n",
    "\n",
    "    print(line)\n",
    "\n",
    "\n",
    "# TODO: Bottom half (row: mid-1..0)\n",
    "# Same idea, but transitions reverse.\n",
    "\n",
    "for row in range(mid - 1, -1, -1):\n",
    "    leading_spaces = mid - row\n",
    "    inner_spaces = 2 * row - 1\n",
    "\n",
    "    if row == 0:\n",
    "        line = \" \" * leading_spaces + \"*\"\n",
    "    else:\n",
    "        line = \" \" * leading_spaces + \"*\" + \" \" * inner_spaces + \"*\"\n",
    "\n",
    "    print(line)\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "5",
   "metadata": {},
   "source": [
    "## üß© Part 1B ‚Äî Hollow Diamond (One-Loop Approach)\n",
    "\n",
    "### Big idea\n",
    "Use one loop over the full height: `row = 0..height-1`.  \n",
    "Compute distance from the midpoint: `dist = abs(mid - row)`.\n",
    "\n",
    "### State \n",
    "- `height`: odd integer ‚â• 1\n",
    "- `mid`: `height // 2`\n",
    "- `row`: 0..height-1\n",
    "- `dist`: distance from midpoint, `abs(mid - row)`\n",
    "- `leading_spaces`: derived from `dist`\n",
    "- `inner_spaces`: derived from `dist`\n",
    "- `line`: printed row\n",
    "\n",
    "### Transitions \n",
    "- `row` increases from `0` to `height-1`\n",
    "- `dist` decreases until the midpoint, then increases after\n",
    "- `leading_spaces` mirrors `dist` (decreases then increases)\n",
    "- `inner_spaces` increases to the midpoint then decreases\n",
    "\n",
    "### Invariants \n",
    "For every printed row:\n",
    "1. The row begins with exactly `leading_spaces` spaces.\n",
    "2. If `inner_spaces < 0` (the ‚Äútip‚Äù rows), print exactly one `*`.\n",
    "3. Otherwise print `*`, then `inner_spaces` spaces, then `*`.\n",
    "4. Output is symmetric vertically and horizontally.\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "6",
   "metadata": {},
   "source": [
    "### ‚úçÔ∏è Invariant Check (write your answer here)\n",
    "- Explain why using `dist = abs(mid - row)` automatically creates symmetry.\n",
    "\n",
    "The distance from the midpoint is the same for row 1 and row 7 (both are 3 away from mid=4 in a height-9 diamond). Using absolute value means rows equidistant from the middle get the same spacing, creating vertical symmetry.\n",
    "\n",
    "- Explain what `inner_spaces < 0` means in terms of the *shape* of the diamond.\n",
    "\n",
    "This occurs only at the top and bottom tips (where dist == mid). A negative value indicates there's no room between two stars‚Äîwe should print only one star instead.\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "7",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "    *\n",
      "   * *\n",
      "  *   *\n",
      " *     *\n",
      "*       *\n",
      " *     *\n",
      "  *   *\n",
      "   * *\n",
      "    *\n"
     ]
    }
   ],
   "source": [
    "# Part 1B ‚Äî Hollow Diamond (One Loop)\n",
    "\n",
    "height = int(input(\"Enter an odd number for the diamond height: \"))\n",
    "\n",
    "# TODO: Compute midpoint\n",
    "mid = height//2\n",
    "\n",
    "# TODO: For row in 0..height-1:\n",
    "#   dist = ...\n",
    "#   leading_spaces = ...\n",
    "#   inner_spaces = ...\n",
    "#   build line using the outline rules\n",
    "#   print line\n",
    "\n",
    "for row in range(height):\n",
    "    dist = abs(mid - row)\n",
    "    leading_spaces = dist\n",
    "    inner_spaces = 2 * (mid - dist) - 1\n",
    "    \n",
    "    if inner_spaces < 0:\n",
    "        line = ' ' * leading_spaces + '*'\n",
    "    else:\n",
    "        line = ' ' * leading_spaces + '*' + ' ' * inner_spaces + '*'\n",
    "    print(line)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "8",
   "metadata": {},
   "source": [
    "## üß© Part 2 ‚Äî Text Analysis\n",
    "\n",
    "### Problem statement\n",
    "Given a **paragraph of text input**, count:\n",
    "1. **Letters**: only `A‚ÄìZ` and `a‚Äìz`  \n",
    "2. **Words**: words are separated by **exactly one space**  \n",
    "3. **Sentences**: sentences end with one of these characters: `.`, `?`, `!`\n",
    "\n",
    "You may assume:\n",
    "- The input uses **single spaces** between words (no tabs, no double spaces).\n",
    "- Sentence endings are identified **only** by `. ? !`.\n",
    "\n",
    "### State \n",
    "- `text`: the input paragraph\n",
    "- `letters`: count of alphabetic characters (A‚ÄìZ, a‚Äìz)\n",
    "- `words`: count of words (based on single spaces)\n",
    "- `sentences`: count of `.`, `?`, `!`\n",
    "- `ch`: current character during scan\n",
    "\n",
    "### Transitions \n",
    "- Initialize counters to 0.\n",
    "- Scan each character `ch`:\n",
    "  - If `ch` is a letter ‚Üí increment `letters`\n",
    "  - If `ch` is `.`, `?`, or `!` ‚Üí increment `sentences`\n",
    "- Compute `words` using the spacing rule (single spaces).\n",
    "\n",
    "### Invariants \n",
    "- Counts never decrease.\n",
    "- `letters` counts only A‚ÄìZ/a‚Äìz.\n",
    "- `sentences` counts only `. ? !`.\n",
    "- `words` is consistent with the ‚Äúone space between words‚Äù assumption.\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "9",
   "metadata": {},
   "source": [
    "### ‚úçÔ∏è Invariant Check (write your answer here)\n",
    "- Suppose the paragraph is non-empty and uses exactly one space between words.\n",
    "  Explain why ‚Äúcount spaces + 1‚Äù gives the correct number of words.\n",
    "\n",
    "If words are separated by exactly one space, then n words have (n-1) spaces between them. So: spaces + 1 = words. Example: \"Hello world\" has 1 space and 2 words.\n",
    "\n",
    "- Give one example where this invariant would break if there were *double spaces*.\n",
    "\n",
    "\"Hello  world\" (two spaces) has 2 spaces, so the formula gives 3 words, but there are actually only 2 words. The invariant breaks because our assumption of \"exactly one space\" is violated.\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "10",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Letters: 5\n",
      "Words: 1\n",
      "Sentences: 0\n"
     ]
    }
   ],
   "source": [
    "# Part 2 ‚Äî Text Analysis (Student TODO)\n",
    "\n",
    "text = input(\"Enter a paragraph:\\n\")\n",
    "\n",
    "# TODO: Initialize state\n",
    "letters = 0\n",
    "sentences = 0\n",
    "spaces = 0\n",
    "\n",
    "# TODO: Scan characters and update letters and sentences\n",
    "\n",
    "for ch in text:\n",
    "    if ch.isalpha():\n",
    "        letters += 1\n",
    "    elif ch in '.?!':\n",
    "        sentences += 1\n",
    "    elif ch == ' ':\n",
    "        spaces += 1\n",
    "\n",
    "# TODO: Compute word count using the rule:\n",
    "\n",
    "words = spaces + 1 if text else 0\n",
    "\n",
    "    \n",
    "# \"Words are separated by exactly one space.\"\n",
    "\n",
    "print(f\"Letters: {letters}\")\n",
    "print(f\"Words: {words}\")\n",
    "print(f\"Sentences: {sentences}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "11",
   "metadata": {},
   "source": [
    "## üß© Part 3 ‚Äî Caesar Cipher (Dictionary Mapping Version)\n",
    "\n",
    "### What is a Caesar cipher?\n",
    "A **Caesar cipher** is a substitution cipher that shifts each letter forward through the alphabet by a fixed amount.\n",
    "\n",
    "Example with shift = 3:\n",
    "- `A ‚Üí D`, `B ‚Üí E`, `C ‚Üí F`, ‚Ä¶\n",
    "- `X ‚Üí A`, `Y ‚Üí B`, `Z ‚Üí C` (wrap-around)\n",
    "\n",
    "With a shift of 8, `'hello'` becomes `'PMTTW'` (using uppercase output).\n",
    "\n",
    "### Rules for this lab\n",
    "- Support **encrypt** and **decrypt**.\n",
    "- Convert the input to **uppercase** first (so output is uppercase too).\n",
    "- Leave **non-letter characters** unchanged (spaces, punctuation, digits).\n",
    "- Use a **dictionary mapping**:\n",
    "  - `encrypt_map`: keys are `A‚ÄìZ`, values are shifted letters\n",
    "  - `decrypt_map`: keys are shifted letters, values are `A‚ÄìZ`\n",
    "\n",
    "---\n",
    "\n",
    "### State \n",
    "- `text_raw`: the original input string\n",
    "- `text`: the uppercase version of the input (`text_raw.upper()`)\n",
    "- `shift`: integer shift value (may be larger than 26)\n",
    "- `shift_norm`: normalized shift in the range `0..25` (computed from `shift`)\n",
    "- `alphabet`: a sequence containing `A..Z` in order\n",
    "- `shifted`: a sequence containing the shifted alphabet (a rotation of `alphabet`)\n",
    "- `encrypt_map`: dict mapping each letter in `alphabet` to the corresponding letter in `shifted`\n",
    "- `decrypt_map`: dict mapping each letter in `shifted` back to the corresponding letter in `alphabet`\n",
    "- `mode`: `'e'` to encrypt or `'d'` to decrypt\n",
    "- `result`: output string built one character at a time\n",
    "- `ch`: the current character being processed\n",
    "- `active_map`: either `encrypt_map` or `decrypt_map` depending on `mode`\n",
    "\n",
    "### Transitions \n",
    "1. Read inputs: `text_raw`, `shift`, `mode`.\n",
    "2. Convert to uppercase:\n",
    "   - `text = text_raw.upper()`\n",
    "3. Normalize the shift:\n",
    "   - `shift_norm = shift % 26`\n",
    "4. Build the two alphabets:\n",
    "   - `alphabet = ['A', 'B', ..., 'Z']`\n",
    "   - `shifted` is `alphabet` rotated left by `shift_norm`\n",
    "5. Build dictionaries:\n",
    "   - `encrypt_map[alphabet[i]] = shifted[i]` for all `i`\n",
    "   - `decrypt_map[shifted[i]] = alphabet[i]` for all `i`\n",
    "6. Choose the active mapping:\n",
    "   - if `mode == 'e'` ‚Üí `active_map = encrypt_map`\n",
    "   - if `mode == 'd'` ‚Üí `active_map = decrypt_map`\n",
    "7. Process characters in `text` left-to-right:\n",
    "   - If `ch` is in `A..Z` ‚Üí append `active_map[ch]` to `result`\n",
    "   - Else ‚Üí append `ch` unchanged to `result`\n",
    "\n",
    "### Invariants \n",
    "- **Length invariant:** after processing `k` characters, `len(result) == k`.\n",
    "- **Non-letter invariant:** any character not in `A..Z` is unchanged and stays in the same position.\n",
    "- **Alphabet invariant:** any letter output is always in `A..Z`.\n",
    "- **Bijection invariant (key idea):**\n",
    "  - `encrypt_map` is a one-to-one mapping from `A..Z` onto `A..Z` (a permutation).\n",
    "  - `decrypt_map` is the inverse of `encrypt_map`.\n",
    "  - Therefore for any letter `L`: `decrypt_map[ encrypt_map[L] ] == L`.\n",
    "- **Shift normalization invariant:** using `shift_norm = shift % 26` does not change the mapping‚Äôs meaning (shifting by 27 is the same as shifting by 1).\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "12",
   "metadata": {},
   "source": [
    "### ‚úçÔ∏è Invariant Check (write your answer here)\n",
    "1. Explain why `encrypt_map` must be a **bijection** (one-to-one and onto) for decryption to be possible.\n",
    "\n",
    "If two different letters mapped to the same encrypted letter, we couldn't decrypt uniquely. We'd lose information. A bijection ensures every letter has exactly one encrypted version and every encrypted letter came from exactly one original letter.\n",
    "\n",
    "2. Explain why building `decrypt_map` by reversing the pairs makes it the **inverse** of `encrypt_map`.\n",
    "\n",
    "If encrypt_map['A'] = 'D', then setting decrypt_map['D'] = 'A' means encrypting then decrypting returns the original: decrypt_map[encrypt_map['A']] = decrypt_map['D'] = 'A'.\n",
    "\n",
    "3. Explain why `shift_norm = shift % 26` does not change the cipher (why is shift 29 equivalent to shift 3?).\n",
    "\n",
    "The alphabet has 26 letters. Shifting by 29 is the same as shifting by 26 (one complete cycle, back to start) + 3 more. So shift 29 ‚â° shift 3."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "13",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Result: PMTTW\n"
     ]
    }
   ],
   "source": [
    "# Part 3 ‚Äî Caesar Cipher (Student TODO, Dictionary Mapping Version)\n",
    "\n",
    "text_raw = input(\"Enter text: \")\n",
    "shift = int(input(\"Enter shift value (integer): \"))\n",
    "mode = input(\"Type 'e' to encrypt or 'd' to decrypt: \").lower()\n",
    "\n",
    "# TODO: Convert to uppercase (this version outputs uppercase)\n",
    "text = text_raw.upper()\n",
    "\n",
    "# TODO: Normalize shift into 0..25\n",
    "shift_norm = shift % 26\n",
    "\n",
    "# TODO: Build alphabet as a list (or string) containing A..Z in order\n",
    "\n",
    "alphabet = list('ABCDEFGHIJKLMNOPQRSTUVWXYZ')\n",
    "\n",
    "\n",
    "# TODO: Build shifted alphabet by rotating alphabet by shift_norm\n",
    "\n",
    "shifted = alphabet[shift_norm:] + alphabet[:shift_norm]\n",
    "\n",
    "# TODO: Build encrypt_map and decrypt_map using alphabet and shifted\n",
    "encrypt_map = {alphabet[i]: shifted[i] for i in range(26)}\n",
    "decrypt_map = {shifted[i]: alphabet[i] for i in range(26)}\n",
    "\n",
    "# TODO: Choose active_map based on mode ('e' or 'd')\n",
    "active_map = encrypt_map if mode == 'e' else decrypt_map\n",
    "\n",
    "# TODO: Build result by iterating through text.\n",
    "# If ch is a letter A..Z, map it with active_map; otherwise keep it unchanged.\n",
    "\n",
    "result = \"\"\n",
    "for ch in text:\n",
    "    if ch in alphabet:\n",
    "        result += active_map[ch]\n",
    "    else:\n",
    "        result += ch\n",
    "\n",
    "print(\"Result:\", result)\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "14",
   "metadata": {},
   "source": [
    "## üß† Reflection (Markdown)\n",
    "\n",
    "Answer in complete sentences.\n",
    "\n",
    "1. For each part, list the **state variables** you actually used in your code.\n",
    "\n",
    "**Part 1A (Hollow Diamond - Two Loops):**\n",
    "- `height`: the odd integer input from the user\n",
    "- `mid`: the midpoint index (height // 2)\n",
    "- `row`: the current row being processed in each loop\n",
    "- `leading_spaces`: number of spaces before the first star\n",
    "- `inner_spaces`: number of spaces between the two stars\n",
    "- `line`: the complete string for each row\n",
    "\n",
    "**Part 1B (Hollow Diamond - One Loop):**\n",
    "- `height`: the odd integer input\n",
    "- `mid`: the midpoint index\n",
    "- `row`: current row (0 to height-1)\n",
    "- `dist`: distance from the midpoint using abs(mid - row)\n",
    "- `leading_spaces`: equals dist\n",
    "- `inner_spaces`: calculated as 2*(mid - dist) - 1\n",
    "- `line`: the string for each row\n",
    "\n",
    "**Part 2 (Text Analysis):**\n",
    "- `text`: the input paragraph\n",
    "- `letters`: counter for alphabetic characters\n",
    "- `sentences`: counter for sentence-ending punctuation\n",
    "- `spaces`: counter for space characters\n",
    "- `words`: calculated from spaces + 1\n",
    "- `ch`: the current character in the loop\n",
    "\n",
    "**Part 3 (Caesar Cipher):**\n",
    "- `text_raw`: original input text\n",
    "- `text`: uppercase version of input\n",
    "- `shift`: the shift value input by user\n",
    "- `shift_norm`: normalized shift (shift % 26)\n",
    "- `alphabet`: list of letters A-Z\n",
    "- `shifted`: rotated alphabet\n",
    "- `encrypt_map`: dictionary mapping letters to shifted letters\n",
    "- `decrypt_map`: inverse dictionary for decryption\n",
    "- `mode`: 'e' or 'd' for encrypt/decrypt\n",
    "- `active_map`: the chosen map based on mode\n",
    "- `result`: the final encrypted or decrypted string\n",
    "- `ch`: current character being processed\n",
    "\n",
    "\n",
    "2. For each part, identify one **transition rule** you relied on most.\n",
    "\n",
    "**Part 1A:**\n",
    "The transition rule I relied on most was: \"leading_spaces = mid - row decreases by 1 each step as row increases.\" This single rule automatically positioned each row correctly because as we move down from the tip (row 0) toward the middle (row mid), the stars move outward by exactly one space per row.\n",
    "\n",
    "**Part 1B:**\n",
    "The most important transition was: \"dist = abs(mid - row) automatically creates symmetry.\" This eliminated the need for two separate loops because the absolute value function naturally creates a mirror effect‚Äîrows equidistant from the middle get identical spacing values.\n",
    "\n",
    "**Part 2:**\n",
    "The transition I relied on most was: \"If ch is a letter, increment letters; if ch is '.?!', increment sentences; if ch is a space, increment spaces.\" This simple character-by-character scanning with conditional updates made it straightforward to count each category in a single pass through the text.\n",
    "\n",
    "3. For each part, name one **invariant** that helped you debug.\n",
    "\n",
    "**Part 1A:**\n",
    "The \"outline invariant\" helped me debug: rows should have exactly one star at tips (row 0) and exactly two stars otherwise. When I first coded it, I forgot the special case for row == 0, and I got negative inner_spaces, which produced incorrect output. The invariant reminded me that the tip must be handled differently.\n",
    "\n",
    "**Part 1B:**\n",
    "The invariant \"inner_spaces < 0 indicates a tip row\" was crucial for debugging. Initially, I tried to always print two stars, which caused an error when inner_spaces was negative. The invariant clarified that negative inner_spaces isn't a bug‚Äîit's a signal that this row should only have one star.\n",
    "\n",
    "**Part 2:**\n",
    "The invariant \"counts never decrease\" helped me verify my logic. As I scanned through the text, I could trace that letters, sentences, and spaces only went up, never down. This confirmed that my conditionals were correctly categorizing each character and not accidentally decrementing counters.\n",
    "\n",
    "**Part 3:**\n",
    "The \"bijection invariant\" (encrypt_map is one-to-one and onto) helped me understand why my code worked. Each letter maps to exactly one encrypted letter, and decrypt_map reverses this perfectly. When testing, I could encrypt a message and then decrypt it, and the bijection invariant guaranteed I'd get back the original text.\n",
    "\n",
    "4. Describe one place where a small bug would violate an invariant and how you would notice.\n",
    "\n",
    "**Scenario:** In Part 1A, suppose I accidentally wrote `inner_spaces = 2 * row` instead of `inner_spaces = 2 * row - 1`.\n",
    "\n",
    "**Invariant violated:** The symmetry invariant would be broken. The diamond would no longer be symmetric about the vertical centerline.\n",
    "\n",
    "**How I would notice:** When I run the program and print the diamond, I'd see that the right edge of the diamond doesn't line up with the left edge‚Äîit would be shifted one space too far to the right on every row (except the tip). Visually, the pattern wouldn't look like a diamond at all. I could also verify this mathematically: for row 1, inner_spaces would be 2 instead of 1, making the line 1 character wider than it should be, and this width error would compound with each row.\n",
    "\n",
    "Additionally, I could test specific rows: for row 2 with mid=4, leading_spaces should be 2 and inner_spaces should be 3, giving a total width of 2 + 1 + 3 + 1 = 7. With the bug, inner_spaces would be 4, giving a width of 8, which violates the expected symmetry.\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "base",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.13.9"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
